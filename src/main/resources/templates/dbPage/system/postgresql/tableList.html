<!DOCTYPE html>
<html lang="zh-TW" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>資料表列表</title>

    <th:block th:if="${_csrf}">
        <meta name="_csrf" th:content="${_csrf.token}"/>
        <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    </th:block>

    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
            line-height: 1.6;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #333;
            padding-bottom: 0.5em;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        a {
            color: #007BFF;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .controls {
            margin-bottom: 1em;
        }
        label {
            font-weight: bold;
            color: #333;
            margin-right: 10px;
        }
        #schema-select {
            padding: 8px 12px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
            color: #333;
            cursor: pointer;
        }
        #schema-select:hover {
            border-color: #a0a0a0;
        }
        #schema-select:focus {
            outline: none;
            border-color: #007BFF;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.25);
        }
    </style>
</head>

<body>

<div class="container">
    <h1>資料表列表</h1>

    <div class="controls">
        <label for="schema-select">選擇 Schema:</label>
        <select id="schema-select"></select>
    </div>

    <table>
        <thead>
        <tr>
            <th>資料表名稱</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody id="table-body">
        </tbody>
    </table>
</div>

<script>
    const API_BASE_URL = "/DBridge/api/postgresql";
    const SCHEMAS_URL = `${API_BASE_URL}/schemas`;
    const TABLES_METADATA_URL = `${API_BASE_URL}/tables/metadata`;

    // 💡 步驟 2: 獲取 CSRF Token 和 Header 名稱
    const csrfToken = document.querySelector('meta[name="_csrf"]')?.getAttribute('content');
    const csrfHeader = document.querySelector('meta[name="_csrf_header"]')?.getAttribute('content');

    // 💡 步驟 3: 輔助函數 - 取得帶有 CSRF Header 的請求設定
    function getRequestOptions(bodyData) {
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(bodyData)
        };

        // 如果 CSRF Token 存在，就將其加入到 Headers 中
        if (csrfToken && csrfHeader) {
            options.headers[csrfHeader] = csrfToken;
        }
        return options;
    }

    // 取得資料表列表並渲染到頁面
    function fetchAndRenderTables(schema) {
        const tableBody = document.getElementById("table-body");

        tableBody.innerHTML = '<tr><td colspan="2">載入中…</td></tr>';

        if (!schema) {
            tableBody.innerHTML = '<tr><td colspan="2">請選擇一個 Schema</td></tr>';
            return;
        }

        // 💡 步驟 4: 使用 getRequestOptions 替換 fetch 參數
        fetch(TABLES_METADATA_URL, getRequestOptions({ schema: schema }))
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP 錯誤! 狀態碼: ${response.status}`);
                }
                return response.json();
            })
            .then(apiResponse => {
                if (apiResponse.code !== "0") {
                    const errorMessage = apiResponse.message || "未知錯誤";
                    tableBody.innerHTML = `<tr><td colspan="2">錯誤: ${errorMessage}</td></tr>`;
                    return;
                }

                const data = apiResponse.data;

                if (!Array.isArray(data) || data.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="2">無資料</td></tr>';
                    return;
                }

                const rowsHtml = data.map(table => {
                    const escapedName = escapeHtml(table.tableName);
                    const remarks = table.remarks ? escapeHtml(table.remarks) : "—";

                    // URL 必須使用當前選中的 schema 變數
                    const detailPageUrl = `/DBridge/view/postgresql/tableMetadata?schema=${encodeURIComponent(schema)}&tableName=${encodeURIComponent(table.tableName)}`;

                    return `
                        <tr>
                            <td><a href="${detailPageUrl}">${escapedName}</a></td>
                            <td>${remarks}</td>
                        </tr>
                    `;
                }).join('');

                tableBody.innerHTML = rowsHtml;
            })
            .catch(error => {
                console.error("載入資料失敗:", error);
                tableBody.innerHTML = `<tr><td colspan="2">載入資料失敗</td></tr>`;
            });
    }

    // 取得 Schema 列表並填充下拉式選單
    function fetchSchemasAndPopulateDropdown(defaultSchemaName) {
        const selectElement = document.getElementById("schema-select");
        let initialSchemaToLoad = null;

        // 💡 步驟 5: 使用 getRequestOptions 替換 fetch 參數
        fetch(SCHEMAS_URL, getRequestOptions({}))
            .then(response => response.json())
            .then(apiResponse => {
                if (apiResponse.code !== "0") {
                    console.error("載入 Schema 列表失敗:", apiResponse.message);
                    selectElement.innerHTML = '<option value="">載入失敗</option>';
                    return;
                }

                const schemas = apiResponse.data;
                if (!Array.isArray(schemas) || schemas.length === 0) {
                    selectElement.innerHTML = '<option value="">無 Schema 可選</option>';
                    return;
                }

                // 1. 根據 API 回傳的 Schema 列表建立 Option
                const optionsHtml = schemas.map(schema => {
                    const escapedSchema = escapeHtml(schema);
                    let selectedAttr = '';

                    // 2. 檢查是否與 URL 傳入的預設 Schema 相符
                    if (defaultSchemaName && schema === defaultSchemaName) {
                        selectedAttr = ' selected';
                        initialSchemaToLoad = schema; // 記住要載入的 Schema
                    }

                    return `<option value="${escapedSchema}"${selectedAttr}>${escapedSchema}</option>`;
                }).join('');

                selectElement.innerHTML = optionsHtml;

                // 3. 確定最終要載入的 Schema：
                const schemaToLoad = initialSchemaToLoad || selectElement.value;

                // 4. 首次載入頁面時，使用確定的 schema
                fetchAndRenderTables(schemaToLoad);

            })
            .catch(error => {
                console.error("載入 Schema 列表失敗:", error);
                selectElement.innerHTML = '<option value="">載入失敗</option>';
            });
    }

    function escapeHtml(s) {
        if (s === null || typeof s === 'undefined') return '';

        return String(s).replace(/[&<>"']/g, c => ({
            "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
        }[c]));
    }

    // 核心啟動邏輯
    document.addEventListener("DOMContentLoaded", () => {
        const urlParams = new URLSearchParams(window.location.search);
        const initialSchema = urlParams.get('schema');

        fetchSchemasAndPopulateDropdown(initialSchema);

        const selectElement = document.getElementById("schema-select");
        selectElement.addEventListener("change", (event) => {
            fetchAndRenderTables(event.target.value);

            if (event.target.value) {
                const newUrl = `${window.location.pathname}?schema=${encodeURIComponent(event.target.value)}`;
                window.history.pushState({ path: newUrl }, '', newUrl);
            } else {
                window.history.pushState({ path: window.location.pathname }, '', window.location.pathname);
            }
        });
    });
</script>

</body>
</html>